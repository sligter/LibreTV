<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LibreTV 播放器</title>

    <!-- Favicon -->
    <link rel="icon" href="https://images.icon-icons.com/38/PNG/512/retrotv_5520.png">
    <link rel="apple-touch-icon" href="https://images.icon-icons.com/38/PNG/512/retrotv_5520.png">
    <link rel="manifest" href="manifest.json">

    <script src="libs/tailwindcss.min.js"></script>
    <script src="js/wakelock.js"></script>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #0f1622;
            color: white;
        }
        .player-container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }
        #player {
            width: 100%;
            height: 60vh; /* 视频播放器高度 */
        }
        .loading-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            z-index: 100;
            flex-direction: column;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 10px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .error-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            z-index: 100;
            flex-direction: column;
            text-align: center;
            padding: 1rem;
        }
        .error-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        .episode-active {
            background-color: #3b82f6 !important;
            border-color: #60a5fa !important;
        }
        .episode-grid {
            max-height: 30vh;
            overflow-y: auto;
            padding-bottom: 1rem;
            margin-top: 1rem;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 46px;
            height: 24px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            transition: .4s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #00ccff;
        }
        input:checked + .slider:before {
            transform: translateX(22px);
        }
        /* 添加快捷键提示样式 */
        .shortcut-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .shortcut-hint.show {
            opacity: 1;
        }

        /* 原生全屏时，播放器容器铺满 */
        .player-container:-webkit-full-screen,
        .player-container:fullscreen {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 10000;
            background-color: #000;
        }
        .player-container:-webkit-full-screen #player,
        .player-container:fullscreen #player {
            width: 100%; height: 100%;
        }
        
        /* 新增：移动端响应式样式 */
        @media (max-width: 640px) {
            .episode-grid {
                max-height: 40vh; /* 移动端增加集数列表高度 */
            }
            
            /* 改进移动端按钮显示 */
            button {
                white-space: nowrap;
            }
            
            /* 控制栏在小屏幕上可能需要换行 */
            .player-container .flex-wrap {
                margin-bottom: 4px;
            }
        }

        /* 弹幕相关样式 - 全部移除，改用DPlayer自带的弹幕样式 */
        #danmakuContainer {
            display: none; /* 隐藏自定义弹幕容器 */
        }
        .danmaku {
            display: none; /* 隐藏自定义弹幕元素 */
        }
        @keyframes danmakuMove {
            from { transform: translateX(100%); }
            to { transform: translateX(-100%); }
        }
        .danmaku-panel {
            position: absolute;
            bottom: 50px;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            z-index: 95;
            display: none;
            flex-direction: column;
            gap: 10px;
        }
        .danmaku-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .danmaku-search {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .danmaku-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 5px;
        }
        .danmaku-item {
            padding: 5px;
            cursor: pointer;
            border-radius: 3px;
        }
        .danmaku-item:hover {
            background-color: #333;
        }
        .danmaku-tabs {
            display: flex;
            border-bottom: 1px solid #333;
        }
        .danmaku-tab {
            padding: 5px 10px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        .danmaku-tab.active {
            border-bottom-color: #00ccff;
            color: #00ccff;
        }
        .danmaku-tab-content {
            display: none;
            padding: 10px 0;
        }
        .danmaku-tab-content.active {
            display: block;
        }
        /* 弹幕API信息 */
        .danmaku-api-info {
            margin-top: 10px;
            padding: 5px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-size: 12px;
            color: #aaa;
        }
        /* 设置项高亮效果 */
        .highlight-setting {
            animation: highlight-pulse 2s ease-in-out;
            position: relative;
        }
        @keyframes highlight-pulse {
            0%, 100% { background-color: transparent; }
            50% { background-color: rgba(0, 204, 255, 0.2); border-radius: 4px; }
        }
        /* Toast消息类型 */
        #toast.success {
            background-color: #10B981;
        }
        #toast.error {
            background-color: #EF4444;
        }
        #toast.info {
            background-color: #3B82F6;
        }
    </style>
</head>
<script>
    // 确保密码验证在页面加载完成后立即运行
    document.addEventListener('DOMContentLoaded', function() {
        // 等待一小段时间确保所有脚本已加载
        setTimeout(function() {
            console.log("初始化密码验证...");
            if (typeof initPasswordProtection === 'function') {
                // 直接调用password.js中的初始化函数
                initPasswordProtection();
            } else {
                console.error("密码验证函数未找到!");
            }
        }, 100);
    });
</script>
<body class="page-bg text-white">
    <header class="bg-[#111] p-4 flex items-center border-b border-[#333] gap-2 player-header">
        <div class="flex items-center min-w-0">
            <a href="/" class="flex items-center min-w-0">
                <svg class="w-8 h-8 mr-2 text-[#00ccff] logo-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                </svg>
                <h1 class="text-xl font-bold gradient-text logo-text">LibreTV</h1>
            </a>
        </div>
        <h2 id="videoTitle" class="text-xl font-semibold flex-1 text-center overflow-x-auto whitespace-nowrap truncate custom-title-scroll"></h2>
        <a href="/" class="px-4 py-2 bg-[#222] hover:bg-[#333] border border-[#333] rounded-lg transition-colors flex items-center min-w-0 home-btn">
            <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 mr-1" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M19 21V9.5l-7-5-7 5V21a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2z" />
              <path d="M9 22V12h6v10" />
            </svg>
            <span class="home-btn-text">返回首页</span>
        </a>
    </header>

    <!-- 密码验证弹窗 -->
    <div id="passwordModal" class="fixed inset-0 bg-black/95 hidden items-center justify-center z-[65] transition-opacity duration-300">
        <div class="bg-[#111] p-8 rounded-lg w-11/12 max-w-md border border-[#333] max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center mb-6 flex-none">
                <h2 class="text-2xl font-bold gradient-text">访问验证</h2>
            </div>
            <div class="mb-6">
                <p class="text-gray-300 mb-4">请输入密码继续访问</p>
                <form id="passwordForm" onsubmit="handlePasswordSubmit(); return false;">
                    <input type="text" name="username" id="username" autocomplete="username" style="display:none" tabindex="-1" aria-hidden="true">
                    <input type="password" id="passwordInput" class="w-full bg-[#111] border border-[#333] text-white px-4 py-3 rounded-lg focus:outline-none focus:border-white transition-colors" placeholder="密码..." autocomplete="new-password">
                    <button id="passwordSubmitBtn" type="submit" class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">提交</button>
                </form>
                <p id="passwordError" class="text-red-500 mt-2 hidden">密码错误，请重试</p>
            </div>
        </div>
    </div>

    <main class="container mx-auto px-4 py-4">
        <!-- 视频播放区 -->
        <div id="playerContainer" class="player-container">
            <div class="relative">
                <div id="player"></div>
                <!-- 弹幕容器 -->
                <div id="danmakuContainer"></div>
                <div class="loading-container" id="loading">
                    <div class="loading-spinner"></div>
                    <div>正在加载视频...</div>
                </div>
                <div class="error-container" id="error">
                    <div class="error-icon">⚠️</div>
                    <div id="error-message">视频加载失败</div>
                    <div style="margin-top: 10px; font-size: 14px; color: #aaa;">请尝试其他视频源或稍后重试</div>
                </div>
                <!-- 弹幕控制面板 -->
                <div id="danmakuPanel" class="danmaku-panel">
                    <div class="danmaku-tabs">
                        <div class="danmaku-tab active" data-tab="settings">弹幕设置</div>
                        <div class="danmaku-tab" data-tab="search">弹幕搜索</div>
                    </div>
                    <div class="danmaku-tab-content active" data-tab="settings">
                        <div class="danmaku-controls">
                            <div class="flex items-center gap-2">
                                <span>显示弹幕</span>
                                <label class="switch">
                                    <input type="checkbox" id="danmakuToggle" checked>
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="flex items-center gap-2">
                                <span>弹幕不透明度</span>
                                <input type="range" id="danmakuOpacity" min="10" max="100" value="80" class="w-24">
                            </div>
                            <div class="flex items-center gap-2">
                                <span>弹幕速度</span>
                                <input type="range" id="danmakuSpeed" min="10" max="200" value="100" class="w-24">
                            </div>
                            <div class="flex items-center gap-2">
                                <span>弹幕大小</span>
                                <input type="range" id="danmakuSize" min="12" max="36" value="23" class="w-24">
                                <span id="sizeValue">23px</span>
                            </div>
                            
                            <!-- 添加弹幕时间偏移设置 -->
                            <div class="flex items-center gap-2 mt-2">
                                <span>时间偏移</span>
                                <input type="range" id="danmakuTimeOffsetSlider" min="-60" max="60" value="0" class="w-24">
                                <div class="flex items-center">
                                    <input type="number" id="danmakuTimeOffsetInput" min="-60" max="60" value="0" 
                                           class="w-12 h-6 bg-[#222] border border-[#333] text-white text-center text-xs rounded">
                                    <span class="ml-1">秒</span>
                                </div>
                            </div>
                            
                            <!-- 添加弹幕颜色选择 -->
                            <div class="flex items-center gap-2 mt-2">
                                <span>弹幕颜色</span>
                                <div class="flex gap-1">
                                    <button class="w-6 h-6 rounded-full border border-white bg-white danmaku-color" data-color="#ffffff" title="白色"></button>
                                    <button class="w-6 h-6 rounded-full border border-white bg-yellow-300 danmaku-color" data-color="#fcd34d" title="黄色"></button>
                                    <button class="w-6 h-6 rounded-full border border-white bg-red-500 danmaku-color" data-color="#ef4444" title="红色"></button>
                                    <button class="w-6 h-6 rounded-full border border-white bg-green-400 danmaku-color" data-color="#4ade80" title="绿色"></button>
                                    <button class="w-6 h-6 rounded-full border border-white bg-blue-400 danmaku-color" data-color="#60a5fa" title="蓝色"></button>
                                    <button class="w-6 h-6 rounded-full border border-white bg-purple-400 danmaku-color" data-color="#c084fc" title="紫色"></button>
                                    <button class="w-6 h-6 rounded-full border border-white danmaku-color random-color" data-color="random" title="随机颜色" style="background: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet);"></button>
                                </div>
                            </div>
                            
                            <!-- 添加清除弹幕缓存按钮 -->
                            <div class="flex items-center gap-2 mt-3">
                                <button id="clearDanmakuCacheBtn" class="px-3 py-1 bg-[#222] hover:bg-[#333] border border-[#333] rounded text-white transition">
                                    清除弹幕缓存
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="danmaku-tab-content" data-tab="search">
                        <div class="danmaku-search">
                            <div class="flex gap-2">
                                <select id="danmakuSource" class="bg-[#222] border border-[#333] rounded px-2 py-1">
                                    <option value="企鹅">企鹅</option>
                                    <option value="奇异">奇异</option>
                                    <option value="阿B">阿B</option>
                                    <option value="阿酷">阿酷</option>
                                    <option value="阿芒">阿芒</option>
                                </select>
                                <input type="text" id="danmakuSearchInput" placeholder="输入视频名称" class="flex-1 bg-[#222] border border-[#333] rounded px-2 py-1">
                                <button id="danmakuSearchBtn" class="px-3 py-1 bg-[#00ccff] text-black rounded">搜索</button>
                            </div>
                            <div id="danmakuVideoList" class="danmaku-list hidden">
                                <!-- 搜索结果将在这里动态生成 -->
                            </div>
                            <div id="danmakuEpisodeList" class="danmaku-list hidden">
                                <!-- 集数列表将在这里动态生成 -->
                            </div>
                            <div id="danmakuStatus"></div>
                        </div>
                    </div>
                    
                    <!-- 添加API信息显示 -->
                    <div class="danmaku-api-info">
                        当前弹幕API地址: <span id="currentDanmakuApi"></span>
                        <div class="text-xs mt-1">可在首页设置中修改API地址</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 集数导航 -->
        <div class="player-container">
            <div class="flex justify-between items-center my-4">
                <button onclick="playPreviousEpisode()" id="prevButton" class="px-4 py-2 bg-[#222] hover:bg-[#333] border border-[#333] rounded-lg transition-colors">
                    <svg class="w-5 h-5 inline-block" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                    </svg>
                    上一集
                </button>
                <span class="text-gray-400" id="episodeInfo">加载中...</span>
                <button onclick="playNextEpisode()" id="nextButton" class="px-4 py-2 bg-[#222] hover:bg-[#333] border border-[#333] rounded-lg transition-colors">
                    下一集
                    <svg class="w-5 h-5 inline-block" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                    </svg>
                </button>
            </div>
        </div>

        <!-- 添加自动播放开关和排序按钮 -->
        <div class="player-container">
            <div class="flex flex-wrap justify-end items-center gap-2">
                <!-- 自动连播开关 - 分组到左边 -->
                <div class="flex items-center gap-1 flex-shrink-0 mr-auto">
                    <span class="text-gray-400 text-sm whitespace-nowrap">自动连播</span>
                    <label class="switch">
                        <input type="checkbox" id="autoplayToggle">
                        <span class="slider"></span>
                    </label>
                </div>
                
                <!-- 把各种功能按钮放在右侧 - 在小屏幕上各自占一行 -->
                <div class="flex flex-wrap justify-end gap-2">
                    <!-- 倒序排列按钮 -->
                    <button onclick="toggleEpisodeOrder()" class="px-3 py-1 bg-[#222] hover:bg-[#333] border border-[#333] rounded-lg transition-colors flex items-center space-x-1 flex-shrink-0">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" id="orderIcon" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v3.586L7.707 9.293a1 1 0 00-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 10.586V7z" clip-rule="evenodd" />
                        </svg>
                        <span id="orderText">倒序排列</span>
                    </button>
                    
                    <!-- 复制链接按钮 -->
                    <button title="复制播放链接" onclick="copyLinks()" class="px-2 py-1 bg-[#222] hover:bg-[#333] border border-[#333] text-white rounded-lg transition">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                        </svg>
                    </button>
                    
                    <!-- 弹幕按钮 -->
                    <button id="danmakuBtn" onclick="toggleDanmakuPanel()" title="弹幕设置" 
                            class="px-2 py-1 bg-[#222] hover:bg-[#333] border border-[#333] text-white rounded-lg transition">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z" />
                        </svg>
                    </button>
                    
                    <!-- 锁定控制按钮 - 始终显示在最右侧 -->
                    <button id="lockToggle" onclick="toggleControlsLock()" title="锁定控制" 
                            class="px-2 py-1 bg-[#222] hover:bg-[#333] border border-[#333] text-white rounded-lg transition flex-shrink-0">
                        <svg id="lockIcon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <!-- 默认状态：未锁图标 -->
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M15 11V7a3 3 0 00-6 0v4m-3 4h12v6H6v-6z" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- 集数网格 -->
        <div class="player-container">
            <div class="episode-grid" id="episodesGrid">
                <div class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2" id="episodesList">
                    <!-- 集数将在这里动态加载 -->
                    <div class="col-span-full text-center text-gray-400 py-8">加载中...</div>
                </div>
            </div>
        </div>
    </main>

    <!-- 添加快捷键提示元素 -->
    <div class="shortcut-hint" id="shortcutHint">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" id="shortcutIcon">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
        </svg>
        <span id="shortcutText"></span>
    </div>

    <!-- 错误提示框 -->
    <div id="toast" class="fixed top-4 left-1/2 -translate-x-1/2 bg-red-500 text-white px-6 py-3 rounded-lg shadow-lg transform transition-all duration-300 opacity-0 -translate-y-full z-50">
        <p id="toastMessage"></p>
    </div>

    <!-- 引入纯 JS sha256（HTTP 下依然可用） -->
    <script src="libs/sha256.min.js"></script>
    <script>
        // 保存原始 js‑sha256 实现，避免被 password.js 覆盖
        window._jsSha256 = window.sha256;
    </script>
    
    <script src="libs/hls.min.js" crossorigin="anonymous"></script>
    <script src="libs/DPlayer.min.js" crossorigin="anonymous"></script>

    <script src="js/config.js"></script>
    <script src="js/password.js"></script>
    <script src="js/ui.js"></script>

    <script>
        // 创建全局环境变量对象
        window.__ENV__ = window.__ENV__ || {};
        
        // 注入服务器端环境变量 (将由服务器端替换)
        // PASSWORD 变量将在这里被服务器端注入
        window.__ENV__.PASSWORD = "{{PASSWORD}}";

        // 设置API基础URL变量 - 弹幕服务地址，从localStorage读取，如果没有则使用默认值
        const API_BASE_URL = localStorage.getItem('danmakuApiUrl') || "http://localhost:5000";
        console.log('弹幕API地址:', API_BASE_URL);
        
        // =================================
        // ============== PLAYER ==========
        // =================================
        // 全局变量
        let currentVideoTitle = '';
        let currentEpisodeIndex = 0;
        let currentEpisodes = [];
        let episodesReversed = false;
        let dp = null;
        let currentHls = null; // 跟踪当前HLS实例
        let autoplayEnabled = true; // 默认开启自动连播
        let isUserSeeking = false; // 跟踪用户是否正在拖动进度条
        let videoHasEnded = false; // 跟踪视频是否已经自然结束
        let userClickedPosition = null; // 记录用户点击的位置
        let shortcutHintTimeout = null; // 用于控制快捷键提示显示时间
        let adFilteringEnabled = true; // 默认开启广告过滤
        let progressSaveInterval = null; // 定期保存进度的计时器

        // 弹幕相关变量
        let danmakuEnabled = localStorage.getItem('danmakuEnabled') !== 'false'; // 默认开启
        let danmakuList = []; // 弹幕列表
        let danmakuDisplayed = {}; // 已显示的弹幕ID，防止重复显示
        let danmakuSpeed = parseFloat(localStorage.getItem('danmakuSpeed') || '1.0'); // 弹幕速度因子
        let danmakuOpacity = parseFloat(localStorage.getItem('danmakuOpacity') || '0.8'); // 弹幕透明度
        let danmakuSize = parseInt(localStorage.getItem('danmakuSize') || '23'); // 弹幕大小
        let danmakuArea = parseInt(localStorage.getItem('danmakuArea') || '75'); // 弹幕显示区域，默认75%
        let danmakuColor = localStorage.getItem('danmakuColor') || '#ffffff'; // 弹幕颜色，默认白色
        let danmakuTimeOffset = parseInt(localStorage.getItem('danmakuTimeOffset') || '0'); // 弹幕时间偏移量（秒）
        let danmakuTracks = 15; // 弹幕轨道数量
        let danmakuTrackStatus = []; // 弹幕轨道状态数组
        let currentDanmakuSource = '企鹅'; // 当前弹幕来源
        let lastRequestTime = 0; // 上次请求时间，用于节流
        let loadingDanmaku = false; // 是否正在加载弹幕
        let lastCheckedTime = 0; // 上次检查弹幕的视频时间点

        // 页面加载
        document.addEventListener('DOMContentLoaded', function() {
            // 先检查用户是否已通过密码验证
            if (!isPasswordVerified()) {
                // 隐藏加载提示
                document.getElementById('loading').style.display = 'none';
                return;
            }

            initializePageContent();
        });

        // 监听密码验证成功事件
        document.addEventListener('passwordVerified', () => {
            document.getElementById('loading').style.display = 'block';

            initializePageContent();
        });

        // 初始化页面内容
        function initializePageContent() {
            // 解析URL参数
            const urlParams = new URLSearchParams(window.location.search);
            const videoUrl = urlParams.get('url');
            const title = urlParams.get('title');
            const sourceCode = urlParams.get('source_code');
            let index = parseInt(urlParams.get('index') || '0');
            const episodesList = urlParams.get('episodes'); // 新增：从URL获取集数信息

            // 从localStorage获取数据
            currentVideoTitle = title || localStorage.getItem('currentVideoTitle') || '未知视频';
            currentEpisodeIndex = index;
            
            // 设置自动连播开关状态
            autoplayEnabled = localStorage.getItem('autoplayEnabled') !== 'false'; // 默认为true
            document.getElementById('autoplayToggle').checked = autoplayEnabled;
            
            // 获取广告过滤设置
            adFilteringEnabled = localStorage.getItem(PLAYER_CONFIG.adFilteringStorage) !== 'false'; // 默认为true
            
            // 监听自动连播开关变化
            document.getElementById('autoplayToggle').addEventListener('change', function(e) {
                autoplayEnabled = e.target.checked;
                localStorage.setItem('autoplayEnabled', autoplayEnabled);
            });
            
            // 优先使用URL传递的集数信息，否则从localStorage获取
            try {
                if (episodesList) {
                    // 如果URL中有集数数据，优先使用它
                    currentEpisodes = JSON.parse(decodeURIComponent(episodesList));
                    console.log('从URL恢复集数信息:', currentEpisodes.length);
                } else {
                    // 否则从localStorage获取
                    currentEpisodes = JSON.parse(localStorage.getItem('currentEpisodes') || '[]');
                    console.log('从localStorage恢复集数信息:', currentEpisodes.length);
                }
                
                // 检查集数索引是否有效，如果无效则调整为0
                if (index < 0 || (currentEpisodes.length > 0 && index >= currentEpisodes.length)) {
                    console.warn(`无效的剧集索引 ${index}，调整为范围内的值`);
                    
                    // 如果索引太大，则使用最大有效索引
                    if (index >= currentEpisodes.length && currentEpisodes.length > 0) {
                        index = currentEpisodes.length - 1;
                    } else {
                        index = 0;
                    }
                    
                    // 更新URL以反映修正后的索引
                    const newUrl = new URL(window.location.href);
                    newUrl.searchParams.set('index', index);
                    window.history.replaceState({}, '', newUrl);
                }
                
                // 更新当前索引为验证过的值
                currentEpisodeIndex = index;
                
                episodesReversed = localStorage.getItem('episodesReversed') === 'true';
            } catch (e) {
                console.error('获取集数信息失败:', e);
                currentEpisodes = [];
                currentEpisodeIndex = 0;
                episodesReversed = false;
            }

            // 设置页面标题
            document.title = currentVideoTitle + ' - LibreTV播放器';
            document.getElementById('videoTitle').textContent = currentVideoTitle;

            // 初始化播放器
            if (videoUrl) {
                initPlayer(videoUrl, sourceCode);
                
                // 尝试从URL参数中恢复播放位置
                const position = urlParams.get('position');
                if (position) {
                    setTimeout(() => {
                        if (dp && dp.video) {
                            const positionNum = parseInt(position);
                            if (!isNaN(positionNum) && positionNum > 0) {
                                dp.seek(positionNum);
                                showPositionRestoreHint(positionNum);
                            }
                        }
                    }, 1500);
                }
            } else {
                showError('无效的视频链接');
            }

            // 更新集数信息
            updateEpisodeInfo();
            
            // 渲染集数列表
            renderEpisodes();
            
            // 更新按钮状态
            updateButtonStates();
            
            // 更新排序按钮状态
            updateOrderButton();

            // 添加对进度条的监听，确保点击准确跳转
            setTimeout(() => {
                setupProgressBarPreciseClicks();
            }, 1000);

            // 添加键盘快捷键事件监听
            document.addEventListener('keydown', handleKeyboardShortcuts);

            // 添加页面离开事件监听，保存播放位置
            window.addEventListener('beforeunload', saveCurrentProgress);

            // 新增：页面隐藏（切后台/切标签）时也保存
            document.addEventListener('visibilitychange', function() {
                if (document.visibilityState === 'hidden') {
                    saveCurrentProgress();
                }
            });

            // 新增：视频暂停时也保存
            // 需确保 dp.video 已初始化
            const waitForVideo = setInterval(() => {
                if (dp && dp.video) {
                    dp.video.addEventListener('pause', saveCurrentProgress);

                    // 新增：播放进度变化时节流保存
                    let lastSave = 0;
                    dp.video.addEventListener('timeupdate', function() {
                        const now = Date.now();
                        if (now - lastSave > 5000) { // 每5秒最多保存一次
                            saveCurrentProgress();
                            lastSave = now;
                        }

                        // 处理弹幕显示
                        if (danmakuEnabled) {
                            showDanmakuAtCurrentTime();
                        }
                    });

                    clearInterval(waitForVideo);
                }
            }, 200);

            // 初始化弹幕控件
            initDanmakuControls();
            
            // 初始化弹幕轨道状态
            initDanmakuTracks();
            
            // 初始化播放器后添加这行
            dp.on('loadedmetadata', function() {
                document.getElementById('loading').style.display = 'none';
                videoHasEnded = false; // 视频加载时重置结束标志
                
                // 视频加载完成后重新设置进度条点击监听
                setupProgressBarPreciseClicks();
                
                // 视频加载成功后，在稍微延迟后将其添加到观看历史
                setTimeout(saveToHistory, 3000);
                
                // 启动定期保存播放进度
                startProgressSaveInterval();
                
                // 应用弹幕自定义设置
                applyDanmakuCustomSettings();
                
                // 覆盖发送弹幕的函数，使其支持自定义颜色
                if (dp.danmaku) {
                    const originalSend = dp.danmaku.send;
                    dp.danmaku.send = function(danmaku) {
                        // 如果是对象格式的弹幕，处理颜色
                        if (typeof danmaku === 'object') {
                            // 如果没有设置颜色，使用用户选择的颜色
                            if (!danmaku.color) {
                                // 如果是随机色，生成一个随机颜色
                                if (danmakuColor === 'random') {
                                    danmaku.color = parseInt(getRandomColor().slice(1), 16);
                                } else {
                                    // 使用用户选择的颜色
                                    danmaku.color = parseInt(danmakuColor.slice(1), 16);
                                }
                            }
                        }
                        // 调用原始的发送函数
                        return originalSend.call(this, danmaku);
                    };
                }
            });
        }

        // 清空弹幕缓存
        function clearDanmakuCache() {
            // 清空内存中的弹幕数据
            danmakuList = [];
            danmakuDisplayed = {};
            lastCheckedTime = 0;
            
            // 如果播放器已初始化，清空播放器中的弹幕
            if (dp && dp.danmaku) {
                dp.danmaku.clear();
            }
            
            // 调用后端API清除本地弹幕文件
            fetch(`${API_BASE_URL}/api/danmaku/clearCache`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.code === 200) {
                    showToast(data.message, 'success');
                } else {
                    showToast(data.message || '清除本地弹幕文件失败', 'error');
                }
            })
            .catch(error => {
                console.error('清除本地弹幕文件失败:', error);
                showToast('清除本地弹幕文件失败', 'error');
            });
            
            console.log('已清空弹幕缓存');
        }

        // 初始化弹幕控件
        function initDanmakuControls() {
            // 弹幕开关
            document.getElementById('danmakuToggle').checked = danmakuEnabled;
            document.getElementById('danmakuToggle').addEventListener('change', function(e) {
                toggleDanmaku(e.target.checked);
            });

            // 弹幕透明度
            document.getElementById('danmakuOpacity').value = Math.round(danmakuOpacity * 100);
            document.getElementById('danmakuOpacity').addEventListener('input', function(e) {
                danmakuOpacity = parseInt(e.target.value) / 100;
                if (dp && dp.danmaku) {
                    dp.danmaku.opacity(danmakuOpacity);
                }
                localStorage.setItem('danmakuOpacity', danmakuOpacity.toString());
            });

            // 弹幕速度
            document.getElementById('danmakuSpeed').value = Math.round(danmakuSpeed * 100);
            document.getElementById('danmakuSpeed').addEventListener('input', function(e) {
                danmakuSpeed = parseInt(e.target.value) / 100;
                if (dp && dp.danmaku) {
                    // 最准确的方法是重新创建弹幕对象
                    try {
                        // 尝试更改css变量的方式设置速度
                        const containers = document.getElementsByClassName('dplayer-danmaku-item');
                        for (let i = 0; i < containers.length; i++) {
                            // 根据速度动态调整动画持续时间，速度越快动画时间越短
                            const speed = 8 / danmakuSpeed; // 默认8秒，速度越大，时间越短
                            containers[i].style.animationDuration = `${speed}s`;
                        }
                        console.log(`设置弹幕速度为: ${danmakuSpeed}`);
                    } catch (e) {
                        console.warn('设置弹幕速度失败', e);
                    }
                }
                localStorage.setItem('danmakuSpeed', danmakuSpeed.toString());
            });

            // 弹幕大小
            document.getElementById('danmakuSize').value = danmakuSize;
            document.getElementById('danmakuSize').addEventListener('input', function(e) {
                danmakuSize = parseInt(e.target.value);
                document.getElementById('sizeValue').textContent = `${danmakuSize}px`;
                if (dp && dp.danmaku) {
                    // 通过设置CSS变量控制弹幕大小
                    document.documentElement.style.setProperty('--dplayer-danmaku-font-size', `${danmakuSize}px`);
                    // 给弹幕容器添加类
                    const container = document.querySelector('.dplayer-danmaku');
                    if (container) {
                        container.classList.add('custom-danmaku-size');
                    }
                }
                localStorage.setItem('danmakuSize', danmakuSize.toString());
            });
            
            // 初始化显示弹幕大小值
            document.getElementById('sizeValue').textContent = `${danmakuSize}px`;
            
            // 初始化时间偏移设置
            const timeOffsetSlider = document.getElementById('danmakuTimeOffsetSlider');
            const timeOffsetInput = document.getElementById('danmakuTimeOffsetInput');
            
            // 设置初始值
            timeOffsetSlider.value = danmakuTimeOffset;
            timeOffsetInput.value = danmakuTimeOffset;
            
            // 滑块改变时同步更新输入框
            timeOffsetSlider.addEventListener('input', function(e) {
                const value = parseInt(e.target.value);
                timeOffsetInput.value = value;
                updateDanmakuTimeOffset(value);
            });
            
            // 输入框改变时同步更新滑块
            timeOffsetInput.addEventListener('change', function(e) {
                let value = parseInt(e.target.value);
                
                // 限制输入范围
                if (isNaN(value)) value = 0;
                if (value < -60) value = -60;
                if (value > 60) value = 60;
                
                // 更新UI和设置
                timeOffsetInput.value = value;
                timeOffsetSlider.value = value;
                updateDanmakuTimeOffset(value);
            });
            
            // 弹幕颜色选择
            const colorButtons = document.querySelectorAll('.danmaku-color');
            colorButtons.forEach(button => {
                const color = button.getAttribute('data-color');
                // 设置当前选中的颜色
                if (color === danmakuColor || (color === 'random' && danmakuColor === 'random')) {
                    button.classList.add('ring-2', 'ring-[#00ccff]', 'ring-offset-1');
                }
                
                button.addEventListener('click', function() {
                    // 移除所有按钮的选中状态
                    colorButtons.forEach(btn => btn.classList.remove('ring-2', 'ring-[#00ccff]', 'ring-offset-1'));
                    // 添加当前按钮的选中状态
                    this.classList.add('ring-2', 'ring-[#00ccff]', 'ring-offset-1');
                    
                    // 设置弹幕颜色
                    danmakuColor = this.getAttribute('data-color');
                    localStorage.setItem('danmakuColor', danmakuColor);
                    
                    // 如果当前有弹幕发送框，更新其颜色预览
                    const dplayerSendBox = document.querySelector('.dplayer-comment-setting-color');
                    if (dplayerSendBox) {
                        // 如果是随机色，生成一个随机颜色
                        if (danmakuColor === 'random') {
                            const randomColor = getRandomColor();
                            dplayerSendBox.style.backgroundColor = randomColor;
                        } else {
                            dplayerSendBox.style.backgroundColor = danmakuColor;
                        }
                    }
                });
            });
            
            // 添加清除弹幕缓存按钮事件监听
            document.getElementById('clearDanmakuCacheBtn').addEventListener('click', function() {
                clearDanmakuCache();
            });
            
            // 显示当前弹幕API地址
            document.getElementById('currentDanmakuApi').textContent = API_BASE_URL;
            
            // 添加弹幕区域设置
            const settingsTab = document.querySelector('.danmaku-tab-content[data-tab="settings"]');
            if (settingsTab && !document.getElementById('danmakuAreaControl')) {
                const areaControl = document.createElement('div');
                areaControl.className = 'flex items-center gap-2';
                areaControl.innerHTML = `
                    <span>弹幕区域</span>
                    <input type="range" id="danmakuArea" min="25" max="100" value="${danmakuArea}" class="w-24">
                    <span id="areaValue">${danmakuArea}%</span>
                `;
                
                // 将区域控制添加到设置面板
                const danmakuControls = settingsTab.querySelector('.danmaku-controls');
                if (danmakuControls) {
                    danmakuControls.appendChild(areaControl);
                    
                    // 添加事件监听器
                    document.getElementById('danmakuArea').addEventListener('input', function(e) {
                        danmakuArea = parseInt(e.target.value);
                        document.getElementById('areaValue').textContent = `${danmakuArea}%`;
                        
                        if (dp && dp.danmaku) {
                            // 设置弹幕显示区域 - 直接使用CSS方式控制，不调用不存在的方法
                            // 通过CSS变量设置，增加兼容性
                            document.documentElement.style.setProperty('--dplayer-danmaku-area', `${danmakuArea}%`);
                            
                            // 给弹幕容器添加自定义样式
                            const container = document.querySelector('.dplayer-danmaku');
                            if (container) {
                                container.style.height = `${danmakuArea}%`;
                                container.classList.add('custom-danmaku-size');
                            }
                        }
                        
                        localStorage.setItem('danmakuArea', danmakuArea.toString());
                    });
                }
            }

            // 弹幕标签切换
            document.querySelectorAll('.danmaku-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabName = this.getAttribute('data-tab');
                    
                    // 移除所有标签的active类
                    document.querySelectorAll('.danmaku-tab').forEach(t => {
                        t.classList.remove('active');
                    });
                    
                    // 移除所有内容的active类
                    document.querySelectorAll('.danmaku-tab-content').forEach(c => {
                        c.classList.remove('active');
                    });
                    
                    // 为当前标签和内容添加active类
                    this.classList.add('active');
                    document.querySelector(`.danmaku-tab-content[data-tab="${tabName}"]`).classList.add('active');
                });
            });

            // 弹幕搜索源选择
            document.getElementById('danmakuSource').addEventListener('change', function(e) {
                currentDanmakuSource = e.target.value;
                // 清空之前的搜索结果
                document.getElementById('danmakuVideoList').innerHTML = '';
                document.getElementById('danmakuVideoList').classList.add('hidden');
                document.getElementById('danmakuEpisodeList').innerHTML = '';
                document.getElementById('danmakuEpisodeList').classList.add('hidden');
                document.getElementById('danmakuStatus').textContent = '';
            });

            // 弹幕搜索按钮
            document.getElementById('danmakuSearchBtn').addEventListener('click', function() {
                const keyword = document.getElementById('danmakuSearchInput').value.trim();
                if (keyword) {
                    searchDanmaku(keyword);
                }
            });

            // 弹幕搜索输入框回车事件
            document.getElementById('danmakuSearchInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    const keyword = this.value.trim();
                    if (keyword) {
                        searchDanmaku(keyword);
                    }
                }
            });

            // 默认填入当前视频标题
            document.getElementById('danmakuSearchInput').value = currentVideoTitle;
            
            // 添加CSS样式以支持弹幕大小和区域自定义
            const customStyle = document.createElement('style');
            customStyle.textContent = `
                :root {
                    --dplayer-danmaku-font-size: ${danmakuSize}px;
                    --dplayer-danmaku-area: ${danmakuArea}%;
                    --dplayer-danmaku-speed-scale: ${danmakuSpeed};
                }
                
                .dplayer-danmaku .dplayer-danmaku-item {
                    font-size: var(--dplayer-danmaku-font-size) !important;
                    transition: font-size 0.3s ease;
                }
                
                .dplayer-danmaku.custom-danmaku-size {
                    margin-top: 0 !important;
                    height: var(--dplayer-danmaku-area) !important;
                }
            `;
            document.head.appendChild(customStyle);
        }

        // 切换弹幕显示状态
        function toggleDanmaku(enabled) {
            danmakuEnabled = enabled;
            if (dp && dp.danmaku) {
                if (enabled) {
                    dp.danmaku.show();
                } else {
                    dp.danmaku.hide();
                }
            }
            
            // 保存设置
            localStorage.setItem('danmakuEnabled', enabled.toString());
        }

        // 初始化弹幕轨道状态
        function initDanmakuTracks() {
            danmakuTrackStatus = Array(danmakuTracks).fill(false); // false表示轨道空闲
        }

        // 切换弹幕面板显示状态
        function toggleDanmakuPanel() {
            const panel = document.getElementById('danmakuPanel');
            if (panel.style.display === 'flex') {
                panel.style.display = 'none';
                danmakuPanelVisible = false;
            } else {
                panel.style.display = 'flex';
                danmakuPanelVisible = true;
            }
        }

        // 加载弹幕数据 - 改为手动控制方式
        function loadDanmakuData(danmakus) {
            try {
                // 清空已有弹幕列表和显示状态
                danmakuList = [];
                danmakuDisplayed = {};
                
                if (dp && dp.danmaku) {
                    // 清空DPlayer现有弹幕
                    dp.danmaku.clear();
                }
                
                // 将弹幕按时间排序，并存储到内存中
                danmakuList = danmakus.map(item => {
                    // 提取时间和内容
                    const time = (item.time || item.timepoint || 0); // 保留毫秒单位
                    const text = item.text || item.content || '';
                    // 使用item中的颜色或默认颜色
                    let color = item.color || 16777215; // 默认白色
                    
                    // 返回格式化的弹幕对象
                    return {
                        time: time,  
                        text: text,
                        type: 0,     // 滚动弹幕
                        color: color,
                        displayed: false // 是否已显示
                    };
                }).filter(item => item.text.trim() !== ''); // 过滤空弹幕
                
                // 按时间排序
                danmakuList.sort((a, b) => a.time - b.time);
                
                // 显示加载成功信息
                console.log(`已加载 ${danmakuList.length} 条弹幕到内存，准备按时间显示`);
                console.log(`弹幕时间范围: ${danmakuList[0]?.time}ms - ${danmakuList[danmakuList.length-1]?.time}ms`);
                
                // 设置视频timeupdate事件监听器
                setupDanmakuTimeListener();
                
                return true;
            } catch (e) {
                console.error('加载弹幕数据失败', e);
                return false;
            }
        }
        
        // 设置视频时间监听器，用于显示弹幕
        function setupDanmakuTimeListener() {
            if (!dp || !dp.video) {
                console.warn('播放器未初始化，无法设置弹幕时间监听');
                return;
            }
            
            // 移除现有监听器，防止重复监听
            dp.video.removeEventListener('timeupdate', checkDanmakuDisplay);
            
            // 添加新的监听器
            dp.video.addEventListener('timeupdate', checkDanmakuDisplay);
            console.log('已设置弹幕时间监听器');
        }
        
        // 检查并显示当前时间点的弹幕
        function checkDanmakuDisplay() {
            // 如果未启用弹幕或者播放器未初始化，不处理
            if (!danmakuEnabled || !dp || !dp.video || !dp.danmaku) return;
            
            // 获取当前播放时间（秒）
            const currentTime = dp.video.currentTime;
            
            // 如果时间变化很小，可以跳过处理（提高性能）
            if (Math.abs(currentTime - lastCheckedTime) < 0.1) return;
            lastCheckedTime = currentTime;
            
            // 弹幕时间窗口 (前后0.5秒) - 应用时间偏移
            const adjustedTime = currentTime - danmakuTimeOffset; // 负值是提前，正值是延后
            const timeWindowStart = (adjustedTime * 1000) - 500;
            const timeWindowEnd = (adjustedTime * 1000) + 500;
            
            // 批量收集符合条件的弹幕，然后一次性添加，提高性能
            const matchedDanmakus = [];
            
            danmakuList.forEach((danmaku, index) => {
                // 只处理未显示过且时间在窗口内的弹幕
                if (!danmaku.displayed && 
                    danmaku.time >= timeWindowStart && 
                    danmaku.time <= timeWindowEnd) {
                    
                    // 标记为已显示
                    danmaku.displayed = true;
                    
                    // 确定弹幕颜色
                    let color;
                    if (danmakuColor === 'random') {
                        color = getRandomColor();
                    } else {
                        // 使用用户设置的颜色 或 原有弹幕颜色
                        color = danmakuColor || (danmaku.color ? '#' + danmaku.color.toString(16).padStart(6, '0') : '#ffffff');
                    }
                    
                    // 转换颜色为十六进制值
                    let colorValue = color;
                    if (color.startsWith('#')) {
                        colorValue = parseInt(color.slice(1), 16);
                    }
                    
                    // 添加到匹配列表
                    matchedDanmakus.push({
                        text: danmaku.text,
                        color: colorValue,
                        type: danmaku.type || 0
                    });
                }
            });
            
            // 一次性批量添加弹幕，提高性能
            if (matchedDanmakus.length > 0) {
                // 使用requestAnimationFrame确保在下一帧渲染，避免卡顿
                requestAnimationFrame(() => {
                    matchedDanmakus.forEach(danmaku => {
                        dp.danmaku.draw(danmaku);
                    });
                    
                    // 调试用，显示弹幕数量
                    if (matchedDanmakus.length % 10 === 0) {
                        console.log(`时间${currentTime.toFixed(2)}秒，显示了${matchedDanmakus.length}条弹幕`);
                    }
                });
            }
        }

        // 处理键盘快捷键
        function handleKeyboardShortcuts(e) {
            // 忽略输入框中的按键事件
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            // Alt + 左箭头 = 上一集
            if (e.altKey && e.key === 'ArrowLeft') {
                if (currentEpisodeIndex > 0) {
                    playPreviousEpisode();
                    showShortcutHint('上一集', 'left');
                    e.preventDefault();
                }
            }
            
            // Alt + 右箭头 = 下一集
            if (e.altKey && e.key === 'ArrowRight') {
                if (currentEpisodeIndex < currentEpisodes.length - 1) {
                    playNextEpisode();
                    showShortcutHint('下一集', 'right');
                    e.preventDefault();
                }
            }

            // D键 = 切换弹幕显示状态
            if (e.key === 'd' || e.key === 'D') {
                const toggle = document.getElementById('danmakuToggle');
                toggle.checked = !toggle.checked;
                toggleDanmaku(toggle.checked);
                e.preventDefault();
            }

            // P键 = 切换弹幕面板
            if (e.key === 'p' || e.key === 'P') {
                toggleDanmakuPanel();
                e.preventDefault();
            }
            
            // 弹幕时间偏移调整: [ 向前偏移1秒, ] 向后偏移1秒
            if (e.key === '[') {
                adjustDanmakuTimeOffset(-1);
                e.preventDefault();
            }
            if (e.key === ']') {
                adjustDanmakuTimeOffset(1);
                e.preventDefault();
            }
            
            // Shift + [/] 快速调整10秒
            if (e.shiftKey && e.key === '{') {
                adjustDanmakuTimeOffset(-10);
                e.preventDefault();
            }
            if (e.shiftKey && e.key === '}') {
                adjustDanmakuTimeOffset(10);
                e.preventDefault();
            }
        }

        // 调整弹幕时间偏移量
        function adjustDanmakuTimeOffset(change) {
            let newOffset = danmakuTimeOffset + change;
            
            // 限制范围
            if (newOffset < -60) newOffset = -60;
            if (newOffset > 60) newOffset = 60;
            
            // 更新UI控件
            const slider = document.getElementById('danmakuTimeOffsetSlider');
            const input = document.getElementById('danmakuTimeOffsetInput');
            if (slider && input) {
                slider.value = newOffset;
                input.value = newOffset;
            }
            
            // 应用新的偏移设置
            updateDanmakuTimeOffset(newOffset);
        }

        // 搜索弹幕
        function searchDanmaku(keyword) {
            // 防止频繁请求
            const now = Date.now();
            if (now - lastRequestTime < 1000 || loadingDanmaku) {
                return;
            }
            lastRequestTime = now;
            loadingDanmaku = true;

            // 显示加载状态
            document.getElementById('danmakuStatus').textContent = '正在搜索...';
            
            // 发送请求到服务器，使用API_BASE_URL变量
            const source = currentDanmakuSource;
            fetch(`${API_BASE_URL}/api/danmaku/search?keyword=${encodeURIComponent(keyword)}&source=${encodeURIComponent(source)}`)
                .then(response => response.json())
                .then(data => {
                    loadingDanmaku = false;
                    if (data.code === 200 && data.videos && data.videos.length > 0) {
                        // 更新视频列表
                        const videoList = document.getElementById('danmakuVideoList');
                        videoList.innerHTML = '';
                        videoList.classList.remove('hidden');
                        document.getElementById('danmakuEpisodeList').classList.add('hidden');
                        
                        data.videos.forEach(video => {
                            const item = document.createElement('div');
                            item.className = 'danmaku-item';
                            item.textContent = video.title;
                            item.setAttribute('data-id', video.id);
                            item.addEventListener('click', function() {
                                // 获取视频集数
                                getDanmakuEpisodes(video.id, keyword);
                            });
                            videoList.appendChild(item);
                        });

                        document.getElementById('danmakuStatus').textContent = `找到 ${data.videos.length} 个视频`;
                    } else {
                        document.getElementById('danmakuStatus').textContent = data.message || '未找到相关视频';
                        document.getElementById('danmakuVideoList').classList.add('hidden');
                    }
                })
                .catch(error => {
                    loadingDanmaku = false;
                    console.error('搜索弹幕失败:', error);
                    document.getElementById('danmakuStatus').textContent = '搜索失败，请稍后重试';
                });
        }

        // 获取弹幕集数
        function getDanmakuEpisodes(videoId, keyword) {
            if (loadingDanmaku) return;
            loadingDanmaku = true;

            document.getElementById('danmakuStatus').textContent = '正在获取集数...';
            
            // 发送请求到服务器，使用API_BASE_URL变量
            const source = currentDanmakuSource;
            
            // 构建查询参数
            let queryParams = `videoId=${encodeURIComponent(videoId)}&source=${encodeURIComponent(source)}`;
            
            // 对所有平台都传递keyword参数，确保API可以正常工作
            if (keyword) {
                queryParams += `&keyword=${encodeURIComponent(keyword)}`;
            }
            
            fetch(`${API_BASE_URL}/api/danmaku/episodes?${queryParams}`)
                .then(response => response.json())
                .then(data => {
                    loadingDanmaku = false;
                    if (data.code === 200 && data.episodes && data.episodes.length > 0) {
                        // 更新集数列表
                        const episodeList = document.getElementById('danmakuEpisodeList');
                        episodeList.innerHTML = '';
                        episodeList.classList.remove('hidden');
                        
                        data.episodes.forEach(episode => {
                            const item = document.createElement('div');
                            item.className = 'danmaku-item';
                            item.textContent = episode.title;
                            item.setAttribute('data-id', episode.id);
                            item.addEventListener('click', function() {
                                // 下载弹幕
                                downloadDanmaku(episode.id, keyword);
                            });
                            episodeList.appendChild(item);
                        });

                        document.getElementById('danmakuStatus').textContent = `找到 ${data.episodes.length} 个集数`;
                    } else {
                        document.getElementById('danmakuStatus').textContent = data.message || '未找到集数信息';
                        document.getElementById('danmakuEpisodeList').classList.add('hidden');
                    }
                })
                .catch(error => {
                    loadingDanmaku = false;
                    console.error('获取集数失败:', error);
                    document.getElementById('danmakuStatus').textContent = '获取集数失败，请稍后重试';
                });
        }

        // 下载弹幕
        function downloadDanmaku(danmakuId, keyword) {
            if (loadingDanmaku) return;
            loadingDanmaku = true;

            document.getElementById('danmakuStatus').textContent = '正在下载弹幕...';
            
            // 发送请求到服务器，使用API_BASE_URL变量
            const source = currentDanmakuSource;
            let queryParams = `danmakuId=${encodeURIComponent(danmakuId)}&source=${encodeURIComponent(source)}`;
            
            // 同样传递keyword参数
            if (keyword) {
                queryParams += `&keyword=${encodeURIComponent(keyword)}`;
            }
            
            console.log(`下载弹幕，参数: ${queryParams}`);
            
            // 对于爱奇艺，如果danmakuId包含qipuId属性，优先使用它
            if (source === '奇异' && typeof danmakuId === 'object' && danmakuId.qipuId) {
                console.log('检测到爱奇艺qipuId属性，使用qipuId下载弹幕');
                queryParams = `danmakuId=${encodeURIComponent(danmakuId.qipuId)}&source=${encodeURIComponent(source)}`;
                if (keyword) {
                    queryParams += `&keyword=${encodeURIComponent(keyword)}`;
                }
            }
            
            fetch(`${API_BASE_URL}/api/danmaku/download?${queryParams}`)
                .then(response => response.json())
                .then(data => {
                    loadingDanmaku = false;
                    if (data.code === 200 && data.danmakus && data.danmakus.length > 0) {
                        // 加载弹幕数据 - 在控制台输出前5条弹幕数据用于调试
                        console.log("弹幕数据结构示例:", JSON.stringify(data.danmakus.slice(0, 2)));
                        console.log(`获取到 ${data.danmakus.length} 条弹幕`);
                        
                        // 根据CSV格式确保弹幕数据包含必要的字段
                        // 在这里我们确保每条弹幕都有 timepoint/time 和 content/text 字段
                        const processedDanmakus = data.danmakus.map(item => {
                            // 确保弹幕有正确的时间字段
                            if (item.timepoint !== undefined && item.time === undefined) {
                                item.time = parseInt(item.timepoint);
                            } else if (item.time !== undefined && item.timepoint === undefined) {
                                item.timepoint = parseInt(item.time);
                            }
                            
                            // 确保弹幕有正确的内容字段
                            if (item.content !== undefined && item.text === undefined) {
                                item.text = item.content;
                            } else if (item.text !== undefined && item.content === undefined) {
                                item.content = item.text;
                            }
                            
                            return item;
                        });
                        
                        // 加载处理后的弹幕数据
                        loadDanmakuData(processedDanmakus);
                        document.getElementById('danmakuStatus').textContent = `成功加载 ${data.danmakus.length} 条弹幕`;
                        
                        // 自动关闭面板
                        setTimeout(() => {
                            toggleDanmakuPanel();
                        }, 1500);
                    } else {
                        document.getElementById('danmakuStatus').textContent = data.message || '未找到弹幕数据';
                    }
                })
                .catch(error => {
                    loadingDanmaku = false;
                    console.error('下载弹幕失败:', error);
                    document.getElementById('danmakuStatus').textContent = '下载弹幕失败，请稍后重试';
                });
        }

        // 在当前时间点显示弹幕
        function showDanmakuAtCurrentTime() {
            if (!dp || !dp.video) return;
            
            const currentTime = dp.video.currentTime * 1000; // 转换为毫秒
            const adjustedTime = currentTime - (danmakuTimeOffset * 1000); // 应用时间偏移（毫秒）
            
            // 搜索需要显示的弹幕
            danmakuList.forEach(danmaku => {
                // 检查弹幕时间是否匹配当前播放时间点（允许±500毫秒的误差）
                if (Math.abs(danmaku.time - adjustedTime) <= 500 && !danmaku.shown) {
                    // 标记为已显示
                    danmaku.shown = true;
                    // 显示弹幕
                    showDanmaku(danmaku.text, danmaku.color);
                }
            });
        }

        // 显示单条弹幕
        function showDanmaku(text, color = '#FFFFFF') {
            if (!danmakuEnabled) return;
            
            const container = document.getElementById('danmakuContainer');
            const trackIndex = getAvailableTrack();
            
            // 如果没有可用轨道，丢弃该弹幕
            if (trackIndex === -1) return;
            
            // 创建弹幕元素
            const danmaku = document.createElement('div');
            danmaku.className = 'danmaku';
            danmaku.textContent = text;
            danmaku.style.color = color;
            danmaku.style.top = `${trackIndex * (danmakuSize + 5)}px`; // 计算垂直位置
            danmaku.style.fontSize = `${danmakuSize}px`; // 设置字体大小
            danmaku.style.opacity = danmakuOpacity; // 设置透明度
            
            // 计算动画时间
            const duration = 8 / danmakuSpeed; // 默认8秒，根据速度调整
            danmaku.style.animationDuration = `${duration}s`;
            
            // 将弹幕添加到容器
            container.appendChild(danmaku);
            
            // 标记轨道为占用
            danmakuTrackStatus[trackIndex] = true;
            
            // 监听动画结束事件
            danmaku.addEventListener('animationend', () => {
                // 移除弹幕元素
                container.removeChild(danmaku);
                // 释放轨道
                danmakuTrackStatus[trackIndex] = false;
            });
        }

        // 获取可用的弹幕轨道
        function getAvailableTrack() {
            for (let i = 0; i < danmakuTrackStatus.length; i++) {
                if (!danmakuTrackStatus[i]) {
                    return i;
                }
            }
            return -1; // 没有可用轨道
        }

        // 设置弹幕的时间偏移量
        function setDanmakuTimeOffset(seconds) {
            danmakuTimeOffset = seconds;
            // 保存到localStorage
            localStorage.setItem('danmakuTimeOffset', seconds.toString());
            // 重置所有弹幕的显示状态
            danmakuList.forEach(danmaku => {
                danmaku.displayed = false;
            });
            
            // 在控制台打印调试信息
            console.log(`已设置弹幕时间偏移: ${seconds}秒`);
            
            // 清除现有弹幕显示
            if (dp && dp.danmaku) {
                dp.danmaku.clear();
            }
        }

        // 更新弹幕时间偏移值
        function updateDanmakuTimeOffset(seconds) {
            // 更新偏移量
            danmakuTimeOffset = seconds;
            // 保存到localStorage
            localStorage.setItem('danmakuTimeOffset', seconds.toString());
            
            // 清除和重置弹幕显示状态
            danmakuList.forEach(danmaku => {
                danmaku.displayed = false;
            });
            lastCheckedTime = 0;
            
            // 清除现有弹幕显示
            if (dp && dp.danmaku) {
                dp.danmaku.clear();
            }
            
            // 显示提示
            showToast(`弹幕时间${seconds > 0 ? '延迟' : '提前'}${Math.abs(seconds)}秒`, 'info', 1500);
        }

        // 处理键盘快捷键
        function handleKeyboardShortcuts(e) {
            // 忽略输入框中的按键事件
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            // Alt + 左箭头 = 上一集
            if (e.altKey && e.key === 'ArrowLeft') {
                if (currentEpisodeIndex > 0) {
                    playPreviousEpisode();
                    showShortcutHint('上一集', 'left');
                    e.preventDefault();
                }
            }
            
            // Alt + 右箭头 = 下一集
            if (e.altKey && e.key === 'ArrowRight') {
                if (currentEpisodeIndex < currentEpisodes.length - 1) {
                    playNextEpisode();
                    showShortcutHint('下一集', 'right');
                    e.preventDefault();
                }
            }

            // D键 = 切换弹幕显示状态
            if (e.key === 'd' || e.key === 'D') {
                const toggle = document.getElementById('danmakuToggle');
                toggle.checked = !toggle.checked;
                toggleDanmaku(toggle.checked);
                e.preventDefault();
            }

            // P键 = 切换弹幕面板
            if (e.key === 'p' || e.key === 'P') {
                toggleDanmakuPanel();
                e.preventDefault();
            }
            
            // 弹幕时间偏移调整: [ 向前偏移1秒, ] 向后偏移1秒
            if (e.key === '[') {
                adjustDanmakuTimeOffset(-1);
                e.preventDefault();
            }
            if (e.key === ']') {
                adjustDanmakuTimeOffset(1);
                e.preventDefault();
            }
            
            // Shift + [/] 快速调整10秒
            if (e.shiftKey && e.key === '{') {
                adjustDanmakuTimeOffset(-10);
                e.preventDefault();
            }
            if (e.shiftKey && e.key === '}') {
                adjustDanmakuTimeOffset(10);
                e.preventDefault();
            }
        }

        // 显示快捷键提示
        function showShortcutHint(text, direction) {
            const hintElement = document.getElementById('shortcutHint');
            const textElement = document.getElementById('shortcutText');
            const iconElement = document.getElementById('shortcutIcon');
            
            // 清除之前的超时
            if (shortcutHintTimeout) {
                clearTimeout(shortcutHintTimeout);
            }
            
            // 设置文本和图标方向
            textElement.textContent = text;
            
            if (direction === 'left') {
                iconElement.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>';
            } else {
                iconElement.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>';
            }
            
            // 显示提示
            hintElement.classList.add('show');
            
            // 两秒后隐藏
            shortcutHintTimeout = setTimeout(() => {
                hintElement.classList.remove('show');
            }, 2000);
        }

        // 初始化播放器
        function initPlayer(videoUrl, sourceCode) {
            if (!videoUrl) return;

            // 为弹幕系统生成唯一标识符
            let danmakuId = '';
            try {
                // 尝试从URL中提取视频ID
                const urlObj = new URL(videoUrl);
                danmakuId = urlObj.pathname.split('/').filter(Boolean).pop() || '';
                // 如果获取不到，使用视频标题
                if (!danmakuId || danmakuId === 'index.m3u8') {
                    danmakuId = currentVideoTitle;
                }
            } catch (e) {
                console.warn('无法从URL解析视频ID，使用标题作为ID', e);
                danmakuId = currentVideoTitle;
            }
            
            // 确保存在弹幕ID
            if (!danmakuId) {
                danmakuId = `video_${Date.now()}`;
            }
            console.log('弹幕ID:', danmakuId);

            // 配置HLS.js选项
            const hlsConfig = {
                debug: false,
                loader: adFilteringEnabled ? CustomHlsJsLoader : Hls.DefaultConfig.loader,
                enableWorker: true,
                lowLatencyMode: false,
                backBufferLength: 90,
                maxBufferLength: 30,
                maxMaxBufferLength: 60,
                maxBufferSize: 30 * 1000 * 1000,
                maxBufferHole: 0.5,
                fragLoadingMaxRetry: 6,
                fragLoadingMaxRetryTimeout: 64000,
                fragLoadingRetryDelay: 1000,
                manifestLoadingMaxRetry: 3,
                manifestLoadingRetryDelay: 1000,
                levelLoadingMaxRetry: 4,
                levelLoadingRetryDelay: 1000,
                startLevel: -1,
                abrEwmaDefaultEstimate: 500000,
                abrBandWidthFactor: 0.95,
                abrBandWidthUpFactor: 0.7,
                abrMaxWithRealBitrate: true,
                stretchShortVideoTrack: true,
                appendErrorMaxRetry: 5,  // 增加尝试次数
                liveSyncDurationCount: 3,
                liveDurationInfinity: false
            };
            
            // 创建DPlayer实例
            dp = new DPlayer({
                container: document.getElementById('player'),
                autoplay: true,
                theme: '#00ccff',
                preload: 'auto',
                loop: false,
                lang: 'zh-cn',
                hotkey: true,        // 启用键盘控制，包括空格暂停/播放、方向键控制进度和音量
                mutex: true,
                volume: 0.7,
                screenshot: true,                // 启用截图功能
                preventClickToggle: false,       // 允许点击视频切换播放/暂停
                airplay: true,                   // 在Safari中启用AirPlay功能
                chromecast: true,                // 启用Chromecast投屏功能
                danmaku: {                      // 使用DPlayer官方的弹幕配置
                    id: danmakuId,              // 使用生成的弹幕ID
                    api: `${API_BASE_URL}/api/dplayer/`,  // 弹幕API端点
                    maximum: 1000,              // 最大弹幕数量
                    user: 'guest',              // 默认用户名
                    margin: [10, '25%'],        // 弹幕与容器边界的距离
                    opacity: 0.8,               // 弹幕透明度
                    speedRate: 1.0              // 弹幕速度
                },
                contextmenu: [                   // 自定义右键菜单
                    {
                        text: '弹幕设置',
                        click: (player) => {
                            toggleDanmakuPanel();
                        }
                    },
                    {
                        text: danmakuEnabled ? '隐藏弹幕' : '显示弹幕',
                        click: (player) => {
                            const toggle = document.getElementById('danmakuToggle');
                            toggle.checked = !toggle.checked;
                            toggleDanmaku(toggle.checked);
                            
                            // 更新菜单项文本
                            player.contextmenu.contextmenu[1].text = toggle.checked ? '隐藏弹幕' : '显示弹幕';
                            
                            // 重新显示右键菜单以更新文本
                            setTimeout(() => {
                                player.contextmenu.hide();
                                player.contextmenu.show(200, 200);
                            }, 100);
                        }
                    },
                    {
                        text: '清空弹幕缓存',
                        click: (player) => {
                            clearDanmakuCache();
                        }
                    },
                    {
                        text: '弹幕时间校准',
                        click: (player) => {
                            // 打开弹幕面板并切换到设置标签页
                            const panel = document.getElementById('danmakuPanel');
                            panel.style.display = 'flex';
                            
                            // 激活设置标签
                            document.querySelectorAll('.danmaku-tab').forEach(t => {
                                t.classList.remove('active');
                            });
                            document.querySelectorAll('.danmaku-tab-content').forEach(c => {
                                c.classList.remove('active');
                            });
                            
                            // 激活设置标签
                            document.querySelector('.danmaku-tab[data-tab="settings"]').classList.add('active');
                            document.querySelector('.danmaku-tab-content[data-tab="settings"]').classList.add('active');
                            
                            // 聚焦到时间偏移设置
                            document.getElementById('danmakuTimeOffsetSlider').focus();
                            
                            // 添加高亮效果
                            const timeOffsetControl = document.getElementById('danmakuTimeOffsetSlider').parentNode;
                            timeOffsetControl.classList.add('highlight-setting');
                            setTimeout(() => {
                                timeOffsetControl.classList.remove('highlight-setting');
                            }, 2000);
                        }
                    },
                    {
                        text: '当前弹幕API',
                        click: (player) => {
                            showToast(`API地址: ${API_BASE_URL}`, 'info', 5000);
                        }
                    },
                    {
                        text: '关于 LibreTV',
                        link: 'https://github.com/bestzwei/LibreTV'
                    },
                    {
                        text: '问题反馈',
                        click: (player) => {
                            window.open('https://github.com/bestzwei/LibreTV/issues', '_blank');
                        }
                    }
                ],
                video: {
                    url: videoUrl,
                    type: 'hls',
                    pic: 'image/nomedia.png', // 设置视频封面图
                    customType: {
                        hls: function(video, player) {
                            // 清理之前的HLS实例
                            if (currentHls && currentHls.destroy) {
                                try {
                                    currentHls.destroy();
                                } catch (e) {
                                    console.warn('销毁旧HLS实例出错:', e);
                                }
                            }
                            
                            // 创建新的HLS实例
                            const hls = new Hls(hlsConfig);
                            currentHls = hls;
                            
                            // 跟踪是否已经显示错误
                            let errorDisplayed = false;
                            // 跟踪是否有错误发生
                            let errorCount = 0;
                            // 跟踪视频是否开始播放
                            let playbackStarted = false;
                            // 跟踪视频是否出现bufferAppendError
                            let bufferAppendErrorCount = 0;
                            
                            // 监听视频播放事件
                            video.addEventListener('playing', function() {
                                playbackStarted = true;
                                document.getElementById('loading').style.display = 'none';
                                document.getElementById('error').style.display = 'none';
                            });
                            
                            // 监听视频进度事件
                            video.addEventListener('timeupdate', function() {
                                if (video.currentTime > 1) {
                                    // 视频进度超过1秒，隐藏错误（如果存在）
                                    document.getElementById('error').style.display = 'none';
                                }
                            });

                            hls.loadSource(video.src);
                            hls.attachMedia(video);
                            
                            // enable airplay, from https://github.com/video-dev/hls.js/issues/5989
                            const source = document.createElement('source');
                            source.src = videoUrl;
                            video.appendChild(source);
                            video.disableRemotePlayback = false;
                            
                            hls.on(Hls.Events.MANIFEST_PARSED, function() {
                                video.play().catch(e => {
                                    console.warn('自动播放被阻止:', e);
                                });
                            });
                            
                            hls.on(Hls.Events.ERROR, function(event, data) {
                                console.log('HLS事件:', event, '数据:', data);
                                
                                // 增加错误计数
                                errorCount++;
                                
                                // 处理bufferAppendError
                                if (data.details === 'bufferAppendError') {
                                    bufferAppendErrorCount++;
                                    console.warn(`bufferAppendError 发生 ${bufferAppendErrorCount} 次`);
                                    
                                    // 如果视频已经开始播放，则忽略这个错误
                                    if (playbackStarted) {
                                        console.log('视频已在播放中，忽略bufferAppendError');
                                        return;
                                    }
                                    
                                    // 如果出现多次bufferAppendError但视频未播放，尝试恢复
                                    if (bufferAppendErrorCount >= 3) {
                                        hls.recoverMediaError();
                                    }
                                }
                                
                                // 如果是致命错误，且视频未播放
                                if (data.fatal && !playbackStarted) {
                                    console.error('致命HLS错误:', data);
                                    
                                    // 尝试恢复错误
                                    switch(data.type) {
                                        case Hls.ErrorTypes.NETWORK_ERROR:
                                            console.log("尝试恢复网络错误");
                                            hls.startLoad();
                                            break;
                                        case Hls.ErrorTypes.MEDIA_ERROR:
                                            console.log("尝试恢复媒体错误");
                                            hls.recoverMediaError();
                                            break;
                                        default:
                                            // 仅在多次恢复尝试后显示错误
                                            if (errorCount > 3 && !errorDisplayed) {
                                                errorDisplayed = true;
                                                showError('视频加载失败，可能是格式不兼容或源不可用');
                                            }
                                            break;
                                    }
                                }
                            });
                            
                            // 监听分段加载事件
                            hls.on(Hls.Events.FRAG_LOADED, function() {
                                document.getElementById('loading').style.display = 'none';
                            });
                            
                            // 监听级别加载事件
                            hls.on(Hls.Events.LEVEL_LOADED, function() {
                                document.getElementById('loading').style.display = 'none';
                            });
                        }
                    }
            }
            });
            // 全屏模式下锁定横屏
            dp.on('fullscreen', () => {
                if (window.screen.orientation && window.screen.orientation.lock) {
                    window.screen.orientation.lock('landscape')
                    .then(() => {
                        console.log('屏幕已锁定为横向模式');
                    })
                    .catch((error) => {
                        console.warn('无法锁定屏幕方向，请手动旋转设备:', error);
                    });
                } else {
                    console.warn('当前浏览器不支持锁定屏幕方向，请手动旋转设备。');
                }
            });
            
            // 全屏取消时解锁屏幕方向
            dp.on('fullscreen_cancel', () => {
                if (window.screen.orientation && window.screen.orientation.unlock) {
                    window.screen.orientation.unlock();
                }
            });
            
            dp.on('loadedmetadata', function() {
                document.getElementById('loading').style.display = 'none';
                videoHasEnded = false; // 视频加载时重置结束标志
                
                // 视频加载完成后重新设置进度条点击监听
                setupProgressBarPreciseClicks();
                
                // 视频加载成功后，在稍微延迟后将其添加到观看历史
                setTimeout(saveToHistory, 3000);
                
                // 启动定期保存播放进度
                startProgressSaveInterval();
            });

            dp.on('error', function() {
                // 检查视频是否已经在播放
                if (dp.video && dp.video.currentTime > 1) {
                    console.log('发生错误，但视频已在播放中，忽略');
                    return;
                }
                showError('视频播放失败，请检查视频源或网络连接');
            });

            // 添加移动端长按两倍速播放功能
            setupLongPressSpeedControl();
            
            // 添加seeking和seeked事件监听器，以检测用户是否在拖动进度条
            dp.on('seeking', function() {
                isUserSeeking = true;
                videoHasEnded = false; // 重置视频结束标志
                
                // 如果是用户通过点击进度条设置的位置，确保准确跳转
                if (userClickedPosition !== null && dp.video) {
                    // 确保用户的点击位置被正确应用，避免自动跳至视频末尾
                    const clickedTime = userClickedPosition;
                    
                    // 防止跳转到视频结尾
                    if (Math.abs(dp.video.duration - clickedTime) < 0.5) {
                        // 如果点击的位置非常接近结尾，稍微减少一点时间
                        dp.video.currentTime = Math.max(0, clickedTime - 0.5);
                    } else {
                        dp.video.currentTime = clickedTime;
                    }
                    
                    // 清除记录的位置
                    setTimeout(() => {
                        userClickedPosition = null;
                    }, 200);
                }
            });
            
            // 改进seeked事件处理
            dp.on('seeked', function() {
                // 如果视频跳转到了非常接近结尾的位置(小于0.3秒)，且不是自然播放到此处
                if (dp.video && dp.video.duration > 0) {
                    const timeFromEnd = dp.video.duration - dp.video.currentTime;
                    if (timeFromEnd < 0.3 && isUserSeeking) {
                        // 将播放时间往回移动一点点，避免触发结束事件
                        dp.video.currentTime = Math.max(0, dp.video.currentTime - 1);
                    }
                }
                
                // 延迟重置seeking标志，以便于区分自然播放结束和用户拖拽
                setTimeout(() => {
                    isUserSeeking = false;
                }, 200);
            });
            
            // 修改视频结束事件监听器，添加额外检查
            dp.on('ended', function() {
                videoHasEnded = true; // 标记视频已自然结束
                
                // 视频已播放完，清除播放进度记录
                clearVideoProgress();
                
                // 如果启用了自动连播，并且有下一集可播放，则自动播放下一集
                if (autoplayEnabled && currentEpisodeIndex < currentEpisodes.length - 1) {
                    console.log('视频播放结束，自动播放下一集');
                    // 稍长延迟以确保所有事件处理完成
                    setTimeout(() => {
                        // 确认不是因为用户拖拽导致的假结束事件
                        if (videoHasEnded && !isUserSeeking) {
                            playNextEpisode();
                            videoHasEnded = false; // 重置标志
                        }
                    }, 1000);
                } else {
                    console.log('视频播放结束，无下一集或未启用自动连播');
                }
            });
            
            // 添加事件监听以检测近视频末尾的点击拖动
            dp.on('timeupdate', function() {
                if (dp.video && dp.duration > 0) {
                    // 如果视频接近结尾但不是自然播放到结尾，重置自然结束标志
                    if (isUserSeeking && dp.video.currentTime > dp.video.duration * 0.95) {
                        videoHasEnded = false;
                    }
                }
            });
            
            // 10秒后如果仍在加载，但不立即显示错误
            setTimeout(function() {
                // 如果视频已经播放开始，则不显示错误
                if (dp && dp.video && dp.video.currentTime > 0) {
                    return;
                }
                
                if (document.getElementById('loading').style.display !== 'none') {
                    document.getElementById('loading').innerHTML = `
                        <div class="loading-spinner"></div>
                        <div>视频加载时间较长，请耐心等待...</div>
                        <div style="font-size: 12px; color: #aaa; margin-top: 10px;">如长时间无响应，请尝试其他视频源</div>
                    `;
                }
            }, 10000);

            // 绑定原生全屏：DPlayer 触发全屏时调用 requestFullscreen
            (function(){
                const fsContainer = document.getElementById('playerContainer');
                dp.on('fullscreen', () => {
                    if (fsContainer.requestFullscreen) {
                        fsContainer.requestFullscreen().catch(err => console.warn('原生全屏失败:', err));
                    }
                });
                dp.on('fullscreen_cancel', () => {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    }
                });
            })();
        }

        // 自定义M3U8 Loader用于过滤广告
        class CustomHlsJsLoader extends Hls.DefaultConfig.loader {
            constructor(config) {
                super(config);
                const load = this.load.bind(this);
                this.load = function(context, config, callbacks) {
                    // 拦截manifest和level请求
                    if (context.type === 'manifest' || context.type === 'level') {
                        const onSuccess = callbacks.onSuccess;
                        callbacks.onSuccess = function(response, stats, context) {
                            // 如果是m3u8文件，处理内容以移除广告分段
                            if (response.data && typeof response.data === 'string') {
                                // 过滤掉广告段 - 实现更精确的广告过滤逻辑
                                response.data = filterAdsFromM3U8(response.data, true);
                            }
                            return onSuccess(response, stats, context);
                        };
                    }
                    // 执行原始load方法
                    load(context, config, callbacks);
                };
            }
        }

        // M3U8清单广告过滤函数
        function filterAdsFromM3U8(m3u8Content, strictMode = false) {
            if (!m3u8Content) return '';

            // 按行分割M3U8内容
            const lines = m3u8Content.split('\n');
            const filteredLines = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                // 只过滤#EXT-X-DISCONTINUITY标识
                if (!line.includes('#EXT-X-DISCONTINUITY')) {
                    filteredLines.push(line);
                }
            }

            return filteredLines.join('\n');
        }
        

        // 显示错误
        function showError(message) {
            // 在视频已经播放的情况下不显示错误
            if (dp && dp.video && dp.video.currentTime > 1) {
                console.log('忽略错误:', message);
                return;
            }
            
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'flex';
            document.getElementById('error-message').textContent = message;
        }

        // 更新集数信息
        function updateEpisodeInfo() {
            if (currentEpisodes.length > 0) {
                document.getElementById('episodeInfo').textContent = `第 ${currentEpisodeIndex + 1}/${currentEpisodes.length} 集`;
            } else {
                document.getElementById('episodeInfo').textContent = '无集数信息';
            }
        }

        // 更新按钮状态
        function updateButtonStates() {
            const prevButton = document.getElementById('prevButton');
            const nextButton = document.getElementById('nextButton');
            
            // 处理上一集按钮
            if (currentEpisodeIndex > 0) {
                prevButton.classList.remove('bg-gray-700', 'cursor-not-allowed');
                prevButton.classList.add('bg-[#222]', 'hover:bg-[#333]');
                prevButton.removeAttribute('disabled');
            } else {
                prevButton.classList.add('bg-gray-700', 'cursor-not-allowed');
                prevButton.classList.remove('bg-[#222]', 'hover:bg-[#333]');
                prevButton.setAttribute('disabled', '');
            }
            
            // 处理下一集按钮
            if (currentEpisodeIndex < currentEpisodes.length - 1) {
                nextButton.classList.remove('bg-gray-700', 'cursor-not-allowed');
                nextButton.classList.add('bg-[#222]', 'hover:bg-[#333]');
                nextButton.removeAttribute('disabled');
            } else {
                nextButton.classList.add('bg-gray-700', 'cursor-not-allowed');
                nextButton.classList.remove('bg-[#222]', 'hover:bg-[#333]');
                nextButton.setAttribute('disabled', '');
            }
        }

        // 渲染集数按钮
        function renderEpisodes() {
            const episodesList = document.getElementById('episodesList');
            if (!episodesList) return;
            
            if (!currentEpisodes || currentEpisodes.length === 0) {
                episodesList.innerHTML = '<div class="col-span-full text-center text-gray-400 py-8">没有可用的集数</div>';
                return;
            }
            
            const episodes = episodesReversed ? [...currentEpisodes].reverse() : currentEpisodes;
            let html = '';
            
            episodes.forEach((episode, index) => {
                // 根据倒序状态计算真实的剧集索引
                const realIndex = episodesReversed ? currentEpisodes.length - 1 - index : index;
                const isActive = realIndex === currentEpisodeIndex;
                
                html += `
                    <button id="episode-${realIndex}" 
                            onclick="playEpisode(${realIndex})" 
                            class="px-4 py-2 ${isActive ? 'episode-active' : '!bg-[#222] hover:!bg-[#333] hover:!shadow-none'} !border ${isActive ? '!border-blue-500' : '!border-[#333]'} rounded-lg transition-colors text-center episode-btn">
                        第${realIndex + 1}集
                    </button>
                `;
            });
            
            episodesList.innerHTML = html;
        }

        // 播放指定集数
        function playEpisode(index) {
            // 确保index在有效范围内
            if (index < 0 || index >= currentEpisodes.length) {
                console.error(`无效的剧集索引: ${index}, 当前剧集数量: ${currentEpisodes.length}`);
                showToast(`无效的剧集索引: ${index + 1}，当前剧集总数: ${currentEpisodes.length}`);
                return;
            }
            
            // 保存当前播放进度（如果正在播放）
            if (dp && dp.video && !dp.video.paused && !videoHasEnded) {
                saveCurrentProgress();
            }
            
            // 清除进度保存计时器
            if (progressSaveInterval) {
                clearInterval(progressSaveInterval);
                progressSaveInterval = null;
            }
            
            // 首先隐藏之前可能显示的错误
            document.getElementById('error').style.display = 'none';
            // 显示加载指示器
            document.getElementById('loading').style.display = 'flex';
            document.getElementById('loading').innerHTML = `
                <div class="loading-spinner"></div>
                <div>正在加载视频...</div>
            `;
            
            // 清除之前视频的弹幕
            if (dp && dp.danmaku) {
                dp.danmaku.clear();
            }
            // 清空弹幕列表和显示状态
            danmakuList = [];
            danmakuDisplayed = {};
            lastCheckedTime = 0;
            
            const url = currentEpisodes[index];
            currentEpisodeIndex = index;
            videoHasEnded = false; // 重置视频结束标志
            
            // 获取当前URL参数，保留source参数
            const urlParams = new URLSearchParams(window.location.search);
            const sourceName = urlParams.get('source') || '';
            const sourceCode = urlParams.get('source_code') || '';
            
            // 更新URL，不刷新页面，保留source参数
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('index', index);
            newUrl.searchParams.set('url', url);
            if (sourceName) {
                newUrl.searchParams.set('source', sourceName);
            }
            if (sourceCode) {
                newUrl.searchParams.set('source_code', sourceCode);
            }
            window.history.pushState({}, '', newUrl);
            
            // 更新播放器
            if (dp) {
                try {
                    dp.switchVideo({
                        url: url,
                        type: 'hls'
                    });
                    
                    // 确保播放开始
                    const playPromise = dp.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.warn('播放失败，尝试重新初始化:', error);
                            // 如果切换视频失败，重新初始化播放器
                            initPlayer(url, sourceCode);
                        });
                    }
                } catch (e) {
                    console.error('切换视频出错，尝试重新初始化:', e);
                    // 如果出错，重新初始化播放器
                    initPlayer(url, sourceCode);
                }
            } else {
                initPlayer(url, sourceCode);
            }
            
            // 更新UI
            updateEpisodeInfo();
            updateButtonStates();
            renderEpisodes();

            // 重置用户点击位置记录
            userClickedPosition = null;
            
            // 三秒后保存到历史记录
            setTimeout(() => saveToHistory(), 3000);
        }

        // 播放上一集
        function playPreviousEpisode() {
            if (currentEpisodeIndex > 0) {
                playEpisode(currentEpisodeIndex - 1);
            }
        }

        // 播放下一集
        function playNextEpisode() {
            if (currentEpisodeIndex < currentEpisodes.length - 1) {
                playEpisode(currentEpisodeIndex + 1);
            }
        }

        // 复制播放链接
        function copyLinks() {
            // 尝试从URL中获取参数
            const urlParams = new URLSearchParams(window.location.search);
            const linkUrl = urlParams.get('url') || '';
            navigator.clipboard.writeText(linkUrl).then(() => {
                showToast('播放链接已复制', 'success');
            }).catch(err => {
                showToast('复制失败，请检查浏览器权限', 'error');
            });
        }

        // 切换集数排序
        function toggleEpisodeOrder() {
            episodesReversed = !episodesReversed;
            
            // 保存到localStorage
            localStorage.setItem('episodesReversed', episodesReversed);
            
            // 重新渲染集数列表
            renderEpisodes();
            
            // 更新排序按钮
            updateOrderButton();
        }

        // 更新排序按钮状态
        function updateOrderButton() {
            const orderText = document.getElementById('orderText');
            const orderIcon = document.getElementById('orderIcon');
            
            if (orderText && orderIcon) {
                orderText.textContent = episodesReversed ? '正序排列' : '倒序排列';
                orderIcon.style.transform = episodesReversed ? 'rotate(180deg)' : '';
            }
        }

        // 设置进度条准确点击处理
        function setupProgressBarPreciseClicks() {
            // 查找DPlayer的进度条元素
            const progressBar = document.querySelector('.dplayer-bar-wrap');
            if (!progressBar || !dp || !dp.video) return;
            
            // 移除可能存在的旧事件监听器
            progressBar.removeEventListener('mousedown', handleProgressBarClick);
            
            // 添加新的事件监听器
            progressBar.addEventListener('mousedown', handleProgressBarClick);
            
            // 在移动端也添加触摸事件支持
            progressBar.removeEventListener('touchstart', handleProgressBarTouch);
            progressBar.addEventListener('touchstart', handleProgressBarTouch);
            
            console.log('进度条精确点击监听器已设置');
        }

        // 处理进度条点击
        function handleProgressBarClick(e) {
            if (!dp || !dp.video) return;
            
            // 计算点击位置相对于进度条的比例
            const rect = e.currentTarget.getBoundingClientRect();
            const percentage = (e.clientX - rect.left) / rect.width;
            
            // 计算点击位置对应的视频时间
            const duration = dp.video.duration;
            let clickTime = percentage * duration;
            
            // 处理视频接近结尾的情况
            if (duration - clickTime < 1) {
                // 如果点击位置非常接近结尾，稍微往前移一点
                clickTime = Math.min(clickTime, duration - 1.5);
                console.log(`进度条点击接近结尾，调整时间为 ${clickTime.toFixed(2)}/${duration.toFixed(2)}`);
            }
            
            // 记录用户点击的位置
            userClickedPosition = clickTime;
            
            // 输出调试信息
            console.log(`进度条点击: ${percentage.toFixed(4)}, 时间: ${clickTime.toFixed(2)}/${duration.toFixed(2)}`);
            
            // 阻止默认事件传播，避免DPlayer内部逻辑将视频跳至末尾
            e.stopPropagation();
            
            // 直接设置视频时间
            dp.seek(clickTime);
        }

        // 处理移动端触摸事件
        function handleProgressBarTouch(e) {
            if (!dp || !dp.video || !e.touches[0]) return;
            
            const touch = e.touches[0];
            const rect = e.currentTarget.getBoundingClientRect();
            const percentage = (touch.clientX - rect.left) / rect.width;
            
            const duration = dp.video.duration;
            let clickTime = percentage * duration;
            
            // 处理视频接近结尾的情况
            if (duration - clickTime < 1) {
                clickTime = Math.min(clickTime, duration - 1.5);
            }
            
            // 记录用户点击的位置
            userClickedPosition = clickTime;
            
            console.log(`进度条触摸: ${percentage.toFixed(4)}, 时间: ${clickTime.toFixed(2)}/${duration.toFixed(2)}`);
            
            e.stopPropagation();
            dp.seek(clickTime);
        }
        
        // 在播放器初始化后添加视频到历史记录
        function saveToHistory() {
            // 确保 currentEpisodes 非空
            if (!currentEpisodes || currentEpisodes.length === 0) {
                console.warn('没有可用的剧集列表，无法保存完整的历史记录');
            }
            
            // 尝试从URL中获取参数
            const urlParams = new URLSearchParams(window.location.search);
            const sourceName = urlParams.get('source') || '';
            const sourceCode = urlParams.get('source_code') || '';

            // 获取当前播放进度
            let currentPosition = 0;
            let videoDuration = 0;
            
            if (dp && dp.video) {
                currentPosition = dp.video.currentTime;
                videoDuration = dp.video.duration;
            }

            // 构建要保存的视频信息对象
            const videoInfo = {
                title: currentVideoTitle,
                // 创建基础URL，使用标题作为唯一标识符
                url: `player.html?title=${encodeURIComponent(currentVideoTitle)}&source=${encodeURIComponent(sourceName)}&source_code=${encodeURIComponent(sourceCode)}`,
                episodeIndex: currentEpisodeIndex,
                sourceName: sourceName,
                timestamp: Date.now(),
                // 添加播放进度信息
                playbackPosition: currentPosition > 10 ? currentPosition : 0,
                duration: videoDuration,
                // 重要：保存完整的集数列表，确保进行深拷贝
                episodes: currentEpisodes && currentEpisodes.length > 0 ? [...currentEpisodes] : []
            };
            
            // 如果外部定义了addToViewingHistory函数，则调用它
            if (typeof addToViewingHistory === 'function') {
                addToViewingHistory(videoInfo);
                console.log(`已保存 "${currentVideoTitle}" 的历史记录, 集数数据: ${currentEpisodes.length}集`);
            } else {
                // 否则直接使用本地实现
                try {
                    const history = JSON.parse(localStorage.getItem('viewingHistory') || '[]');
                    
                    // 检查是否已经存在相同标题的记录（同一视频的不同集数）
                    const existingIndex = history.findIndex(item => item.title === videoInfo.title);
                    if (existingIndex !== -1) {
                        // 存在则更新现有记录的集数、时间戳和URL
                        history[existingIndex].episodeIndex = currentEpisodeIndex;
                        history[existingIndex].timestamp = Date.now();
                        history[existingIndex].sourceName = sourceName
                        // 更新播放进度信息
                        history[existingIndex].playbackPosition = currentPosition > 10 ? currentPosition : history[existingIndex].playbackPosition;
                        history[existingIndex].duration = videoDuration || history[existingIndex].duration;
                        // 同时更新URL以保存当前的集数状态
                        history[existingIndex].url = window.location.href;
                        // 更新集数列表（如果有且与当前不同）
                        if (currentEpisodes && currentEpisodes.length > 0) {
                            // 检查是否需要更新集数数据（针对不同长度的集数列表）
                            if (!history[existingIndex].episodes || 
                                !Array.isArray(history[existingIndex].episodes) || 
                                history[existingIndex].episodes.length !== currentEpisodes.length) {
                                history[existingIndex].episodes = [...currentEpisodes]; // 深拷贝
                                console.log(`更新 "${currentVideoTitle}" 的剧集数据: ${currentEpisodes.length}集`);
                            }
                        }
                        
                        // 移到最前面
                        const updatedItem = history.splice(existingIndex, 1)[0];
                        history.unshift(updatedItem);
                    } else {
                        // 添加新记录到最前面，但保存完整URL以便能直接打开到正确的集数
                        videoInfo.url = window.location.href;
                        console.log(`创建新的历史记录: "${currentVideoTitle}", ${currentEpisodes.length}集`);
                        history.unshift(videoInfo);
                    }
                    
                    // 限制历史记录数量为50条
                    if (history.length > 50) history.splice(50);
                    
                    localStorage.setItem('viewingHistory', JSON.stringify(history));
                } catch (e) {
                    console.error('保存观看历史失败:', e);
                }
            }
        }

        // 显示恢复位置提示
        function showPositionRestoreHint(position) {
            if (!position || position < 10) return;
            
            // 创建提示元素
            const hint = document.createElement('div');
            hint.className = 'position-restore-hint';
            hint.innerHTML = `
                <div class="hint-content">
                    已从 ${formatTime(position)} 继续播放
                </div>
            `;
            
            // 添加到播放器容器
            const playerContainer = document.querySelector('.player-container');
            playerContainer.appendChild(hint);
            
            // 显示提示
            setTimeout(() => {
                hint.classList.add('show');
                
                // 3秒后隐藏
                setTimeout(() => {
                    hint.classList.remove('show');
                    setTimeout(() => hint.remove(), 300);
                }, 3000);
            }, 100);
        }
        
        // 格式化时间为 mm:ss 格式
        function formatTime(seconds) {
            if (isNaN(seconds)) return '00:00';
            
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
        // 开始定期保存播放进度
        function startProgressSaveInterval() {
            // 清除可能存在的旧计时器
            if (progressSaveInterval) {
                clearInterval(progressSaveInterval);
            }
            
            // 每30秒保存一次播放进度
            progressSaveInterval = setInterval(saveCurrentProgress, 30000);
        }
        
        // 保存当前播放进度
        function saveCurrentProgress() {
            if (!dp || !dp.video) return;
            const currentTime = dp.video.currentTime;
            const duration = dp.video.duration;
            if (!duration || currentTime < 1) return;

            // 在localStorage中保存进度
            const progressKey = `videoProgress_${getVideoId()}`;
            const progressData = {
                position: currentTime,
                duration: duration,
                timestamp: Date.now()
            };
            try {
                localStorage.setItem(progressKey, JSON.stringify(progressData));
                // --- 新增：同步更新 viewingHistory 中的进度 ---
                try {
                    const historyRaw = localStorage.getItem('viewingHistory');
                    if (historyRaw) {
                        const history = JSON.parse(historyRaw);
                        // 用 title + 集数索引唯一标识
                        const idx = history.findIndex(item =>
                            item.title === currentVideoTitle &&
                            (item.episodeIndex === undefined || item.episodeIndex === currentEpisodeIndex)
                        );
                        if (idx !== -1) {
                            // 只在进度有明显变化时才更新，减少写入
                            if (
                                Math.abs((history[idx].playbackPosition || 0) - currentTime) > 2 ||
                                Math.abs((history[idx].duration || 0) - duration) > 2
                            ) {
                                history[idx].playbackPosition = currentTime;
                                history[idx].duration = duration;
                                history[idx].timestamp = Date.now();
                                localStorage.setItem('viewingHistory', JSON.stringify(history));
                            }
                        }
                    }
                } catch (e) {
                    // 忽略 viewingHistory 更新错误
                }
            } catch (e) {
                console.error('保存播放进度失败', e);
            }
        }

        // 设置移动端长按两倍速播放功能
        function setupLongPressSpeedControl() {
            if (!dp || !dp.video) return;
            
            const playerElement = document.getElementById('player');
            let longPressTimer = null;
            let originalPlaybackRate = 1.0;
            let isLongPress = false;
            
            // 显示快速提示
            function showSpeedHint(speed) {
                showShortcutHint(`${speed}倍速`, 'right');
            }

            // 禁用右键
            playerElement.oncontextmenu =  () => {
                // 检测是否为移动设备
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // 只在移动设备上禁用右键
                if (isMobile) {
                    document.querySelector(".dplayer-menu").style.display = "none";
                    document.querySelector(".dplayer-mask").style.display = "none";
                    return false;
                }
                return true; // 在桌面设备上允许右键菜单
            };
            
            // 触摸开始事件
            playerElement.addEventListener('touchstart', function(e) {
                // 检查视频是否正在播放，如果没有播放则不触发长按功能
                if (dp.video.paused) {
                    return; // 视频暂停时不触发长按功能
                }
                
                // 保存原始播放速度
                originalPlaybackRate = dp.video.playbackRate;
                
                // 设置长按计时器
                longPressTimer = setTimeout(() => {
                    // 再次检查视频是否仍在播放
                    if (dp.video.paused) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                        return;
                    }
                    
                    // 长按超过500ms，设置为3倍速
                    dp.video.playbackRate = 3.0;
                    isLongPress = true;
                    showSpeedHint(3.0);
                    
                    // 只在确认为长按时阻止默认行为
                    e.preventDefault();
                }, 500);
            }, { passive: false });
            
            // 触摸结束事件
            playerElement.addEventListener('touchend', function(e) {
                // 清除长按计时器
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                // 如果是长按状态，恢复原始播放速度
                if (isLongPress) {
                    dp.video.playbackRate = originalPlaybackRate;
                    isLongPress = false;
                    showSpeedHint(originalPlaybackRate);
                    
                    // 阻止长按后的点击事件
                    e.preventDefault();
                }
                // 如果不是长按，则允许正常的点击事件（暂停/播放）
            });
            
            // 触摸取消事件
            playerElement.addEventListener('touchcancel', function() {
                // 清除长按计时器
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                // 如果是长按状态，恢复原始播放速度
                if (isLongPress) {
                    dp.video.playbackRate = originalPlaybackRate;
                    isLongPress = false;
                }
            });
            
            // 触摸移动事件 - 防止在长按时触发页面滚动
            playerElement.addEventListener('touchmove', function(e) {
                if (isLongPress) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // 视频暂停时取消长按状态
            dp.video.addEventListener('pause', function() {
                if (isLongPress) {
                    dp.video.playbackRate = originalPlaybackRate;
                    isLongPress = false;
                }
                
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });
        }
        
        // 清除视频进度记录
        function clearVideoProgress() {
            const progressKey = `videoProgress_${getVideoId()}`;
            try {
                localStorage.removeItem(progressKey);
                console.log('已清除播放进度记录');
            } catch (e) {
                console.error('清除播放进度记录失败', e);
            }
        }
        
        // 获取视频唯一标识
        function getVideoId() {
            // 使用视频标题和集数索引作为唯一标识
            return `${encodeURIComponent(currentVideoTitle)}_${currentEpisodeIndex}`;
        }

        let controlsLocked = false;
        function toggleControlsLock() {
            const container = document.getElementById('playerContainer');
            controlsLocked = !controlsLocked;
            container.classList.toggle('controls-locked', controlsLocked);
            const icon = document.getElementById('lockIcon');
            // 切换图标：锁 / 解锁
            icon.innerHTML = controlsLocked
                ? '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d=\"M12 15v2m0-8V7a4 4 0 00-8 0v2m8 0H4v8h16v-8h-4z\"/>'
                : '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d=\"M15 11V7a3 3 0 00-6 0v4m-3 4h12v6H6v-6z\"/>';
        }

        // 在播放器初始化后应用弹幕自定义设置
        function applyDanmakuCustomSettings() {
            if (!dp || !dp.danmaku) return;
            
            // 设置弹幕透明度
            dp.danmaku.opacity(danmakuOpacity);
            
            // 设置弹幕区域 - 使用CSS方式，而非不存在的API
            document.documentElement.style.setProperty('--dplayer-danmaku-font-size', `${danmakuSize}px`);
            document.documentElement.style.setProperty('--dplayer-danmaku-area', `${danmakuArea}%`);
            
            // 给弹幕容器添加自定义类
            setTimeout(() => {
                const container = document.querySelector('.dplayer-danmaku');
                if (container) {
                    container.style.height = `${danmakuArea}%`;
                    container.classList.add('custom-danmaku-size');
                }
                
                // 设置发送弹幕时的颜色选择器颜色
                const colorPicker = document.querySelector('.dplayer-comment-setting-color');
                if (colorPicker) {
                    if (danmakuColor === 'random') {
                        colorPicker.style.backgroundColor = getRandomColor();
                    } else {
                        colorPicker.style.backgroundColor = danmakuColor;
                    }
                }
                
                // 监听弹幕发送框打开事件，设置默认颜色
                const commentShow = document.querySelector('.dplayer-comment-show');
                if (commentShow) {
                    const observer = new MutationObserver(function(mutations) {
                        mutations.forEach(function(mutation) {
                            if (mutation.attributeName === 'style' && 
                                commentShow.style.display !== 'none') {
                                // 弹幕框显示时，设置颜色
                                const colorPicker = document.querySelector('.dplayer-comment-setting-color');
                                if (colorPicker) {
                                    if (danmakuColor === 'random') {
                                        colorPicker.style.backgroundColor = getRandomColor();
                                    } else {
                                        colorPicker.style.backgroundColor = danmakuColor;
                                    }
                                }
                            }
                        });
                    });
                    observer.observe(commentShow, { attributes: true });
                }
            }, 500);
            
            // 应用弹幕显示状态
            if (danmakuEnabled) {
                dp.danmaku.show();
            } else {
                dp.danmaku.hide();
            }
        }

        // 添加生成随机颜色的函数
        function getRandomColor() {
            const colors = [
                '#ffffff', // 白色
                '#fcd34d', // 黄色
                '#ef4444', // 红色
                '#4ade80', // 绿色
                '#60a5fa', // 蓝色
                '#c084fc'  // 紫色
            ];
            // 随机返回一个颜色或生成完全随机颜色
            if (Math.random() > 0.5) {
                return colors[Math.floor(Math.random() * colors.length)];
            } else {
                return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
            }
        }

        // 添加showToast函数，如果页面中没有
        function showToast(message, type = 'error', duration = 3000) {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            
            if (!toast || !toastMessage) {
                console.error('找不到Toast元素，无法显示消息');
                return;
            }
            
            // 设置消息类型
            toast.className = 'fixed top-4 left-1/2 -translate-x-1/2 px-6 py-3 rounded-lg shadow-lg transform transition-all duration-300 z-50';
            toast.classList.add(type); // 添加类型样式: success, error, info
            
            // 设置消息内容
            toastMessage.textContent = message;
            
            // 显示Toast
            toast.style.opacity = '1';
            toast.style.transform = 'translate(-50%, 0)';
            
            // 定时隐藏
            clearTimeout(window.toastTimeout);
            window.toastTimeout = setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translate(-50%, -100%)';
            }, duration);
        }
    </script>
</body>
</html>
